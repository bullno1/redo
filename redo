#!/bin/sh -e

main() {
	if [ -z "$REDO" ]; then
		export REDO=`readlink -f $0`
		export REDO_META_DIR=`readlink -f ./.redo`
		mkdir -p "$REDO_META_DIR"
		export REDO_BIN_DIR="$REDO_META_DIR/bin"
		mkdir -p "$REDO_BIN_DIR"
		export REDO_DB_DIR="$REDO_META_DIR/db"
		mkdir -p "$REDO_DB_DIR"
		export REDO_PATH="$REDO_BIN_DIR:$PATH"
		register_cmds ifchange ifcreate always graph run log
	fi

	local name=`basename $0`

	case $name in
		redo)
			redo $*
			;;
		redo-*)
			try_dispatch_cmd "${name#redo-}" $*
			;;
		*)
			redo_log "redo: invalid command '$name'"
			exit 1
			;;
	esac
}

redo() {
	case $1 in
		--*)
			local cmd=${1#--}
			shift
			try_dispatch_cmd "$cmd" $*
			;;
		*)
			db_reset_uptodate
			if [ "$#" -eq 0 ]; then
				redo_ifchange all
			else
				redo_ifchange $*
			fi
			;;
	esac
}

redo_ifchange() {
	local i
	local j
	for i in "$@"
	do
		db_add_prereq "$REDO_PARENT" "$i"

		db_get_type "$i"
		local file_type="$db_result"
		local file_type_name=
		case $file_type in
			s)
				file_type_name="source"
				;;
			t)
				file_type_name="target"
				;;
			a)
				file_type_name="live target"
				;;
		esac

		redo_log "Checking $file_type_name file '$i'"

		if db_is_uptodate "$i"; then
			redo_log "'$i' was checked previously"
			continue
		fi

		# A source file only need to have its hash updated
		if [ "$file_type" = "s" ]; then
			if db_update_own_checksum "$i"; then
				redo_log "'$i' was updated"
			else
				redo_log "'$i' is unchanged"
			fi
			db_mark_as_uptodate "$i"

			continue
		fi

		# An existing regular target file may not need to be rebuilt
		if [ "$file_type" = "t" ] && [ -f "$i" ]; then
			local must_build="n"

			# Check if prereqs are up-to-date
			db_get_prereqs "$i"
			local prereqs="$db_result"
			if [ ! -z "$prereqs" ]; then
				for j in $prereqs
				do
					redo_log "Checking prereqs '$j' of '$i'"

					# Update prereq if needed
					if db_outdated "$j"; then
						with_parent "$i" redo_ifchange "$j"
					fi

					# Even if prereq is up-to-date, we may still depend on an old
					# version of it, so check if it was rebuilt since last time
					if db_prereq_rebuilt "$i" "$j"; then
						redo_log "'$j' was updated"
						must_build="y"
					fi
				done
			fi

			# Check all "if-create" prereqs
			db_get_ifcreate_prereqs "$i"
			local ifcreate_prereqs="$db_result"
			if [ ! -z "$ifcreate_prereqs" ]; then
				for j in $ifcreate_prereqs
				do
					if [ -f "$j" ]; then
						redo_log "'$j' was created"
						must_build="y"
						break
					fi
				done
			fi

			# If file exists and it is not required to build, bail out
			if [ "$must_build" = "n" ]; then
				db_mark_as_uptodate "$i"
				redo_log "'$i' is up-to-date"
				continue
			fi
		fi

		# Find and execute build script
		rm -rf "$i"
		rm -rf "$REDO_DB_DIR/$i/.redo/prereqs"
		rm -rf "$REDO_DB_DIR/$i/.redo/ifcreate"
		if find_build_script "$i"; then
			with_parent "$i" redo_ifcreate $non_exist_build_scripts
			local script="$build_script"
			if run_build_script "$i" "$script"; then
				# redo-always targets are always outdated so there's no need
				# to update it's prereqs' checksums
				if [ "$file_type" != "a" ]; then
					db_update_prereqs_checksums "$i"
				fi
				db_update_own_checksum "$i" || true
				db_mark_as_uptodate "$i"
				redo_log "Done with '$i'"
			else
				redo_log "'$script' failed"
				exit 1
			fi
		else
			redo_log "No build script for '$i'"
			exit 1
		fi
	done
}

redo_ifcreate() {
	local i
	for i in "$@"
	do
		db_add_ifcreate_prereq "$REDO_PARENT" "$i"
	done
}

redo_always() {
	db_write "$REDO_DB_DIR/$REDO_PARENT/.redo/type" "a"
}

redo_graph() {
	local i
	local j

	echo "digraph redo {"
	local files=`cd $REDO_DB_DIR; find . -type f -path '*/.redo/type'`
	if [ ! -z "$files" ]; then
		for i in $files
		do
			local filename="${i%/.redo/type}"
			local file_type=
			if db_has_type "$filename"; then
				db_get_type "$filename"
				file_type="$db_result"
			fi
			local attrs=
			case $file_type in
				s)
					attrs="[ shape=box ]"
					;;
				t)
					attrs="[ shape=ellipse ]"
					;;
				a)
					attrs="[ shape=diamond ]"
					;;
				*)
					attrs="[ ]"
					;;
			esac
			echo "	\"$filename\" $attrs"

			db_get_prereqs "$filename"
			local prereqs="$db_result"
			if [ ! -z "$prereqs" ]; then
				for j in $prereqs
				do
					echo "	\"$filename\" -> \"$j\";"
				done
			fi

			db_get_ifcreate_prereqs "$filename"
			local ifcreate_prereqs="$db_result"
			if [ ! -z "$ifcreate_prereqs" ]; then
				for j in $ifcreate_prereqs
				do
					echo "	\"$filename\" -> \"$j\" [ arrowhead=box, color=red ];"
				done
			fi
		done
	fi
	echo "}"
}

redo_log() {
	echo "${REDO_LOG_PREFIX}${*}" >&2
}

redo_run() {
	REDO_SCRIPT=$1
	shift
	REDO_PARENT=$1
	export REDO_PARENT
	export PATH="$REDO_PATH"
	export PS4="$REDO_LOG_PREFIX> "
	sh -ex $REDO_SCRIPT $*
}

redo_clean() {
	local i
	local types=`find .redo -path '*/.redo/type'`
	for i in $types
	do
		local full_key_path=`readlink -f $i`
		local file_path="${full_key_path#${REDO_DB_DIR}/}"
		file_path="${file_path%/.redo/type}"

		local file_type=`cat $i`
		case $file_type in
			s)
				if [ ! -f $file_path ]; then
					local entry_path="$REDO_DB_DIR/$file_path"
					rm -rf $entry_path
					redo_log "Removed db entry for missing source: '$file_path'"
				fi
				;;
			t|a)
				if [ -f "$file_path" ]; then
					rm -f "$file_path"
					redo_log "Removed target $file_path"
				fi
				;;
		esac
	done
}

redo_activate() {
	local old_path="$PATH"
	local new_path="`dirname $REDO`:$PATH"
	activate_script=`cat << SCRIPT
PATH="$new_path"

deactivate_redo() {
	PATH="$old_path"
	unset -f deactivate_redo
}
SCRIPT`
	echo "$activate_script"
}

with_parent() {
	local old_parent="$REDO_PARENT"
	REDO_PARENT="$1"
	local cmd="$2"
	shift 2
	log_wrap "$cmd" $*
	REDO_PARENT="$old_parent"
}

log_wrap() {
	redo_log "${*:-<main>}"
	local old_prefix="$REDO_LOG_PREFIX"
	REDO_LOG_PREFIX="$REDO_LOG_PREFIX  "
	"$@"
	REDO_LOG_PREFIX="$old_prefix"
}

db_get_type() {
	local key="$REDO_DB_DIR/$1/.redo/type"
	if [ -f "$key" ]; then
		db_result=`cat "$key"`
	else
		if [ -f "$1" ]; then
			if find_build_script "$1"; then
				db_result="t"
				redo_log "Warning: '$1' is new but it already has a build script: '$build_script'"
				redo_log "Please run 'redo --clean' before bulding"
			else
				db_result="s"
			fi
		else
			db_result="t"
		fi
		db_write "$key" "$db_result"
	fi
}

db_has_type() {
	local key="$REDO_DB_DIR/$1/.redo/type"
	[ -f "$key" ]
}

db_add_prereq() {
	if [ -z "$1" ]; then
		return 0
	fi

	local key="$REDO_DB_DIR/$1/.redo/prereqs/$2"
	db_affirm_key "$key"
	rm -rf "$REDO_DB_DIR/$1/.redo/ifcreate/$2"
}

db_get_prereqs() {
	local key="$REDO_DB_DIR/$1/.redo/prereqs"
	if [ ! -d "$key" ]; then
		db_result=
	else
		db_result=`cd $key;find -type f`
	fi
}

db_add_ifcreate_prereq() {
	local key="$REDO_DB_DIR/$1/.redo/ifcreate/$2"
	db_affirm_key "$key"
	rm -rf "$REDO_DB_DIR/$1/.redo/prereqs/$2"
}

db_get_ifcreate_prereqs() {
	local key="$REDO_DB_DIR/$1/.redo/ifcreate"
	if [ ! -d "$key" ]; then
		db_result=
	else
		db_result=`cd $key;find -type f`
	fi
}

db_update_own_checksum() {
	local checksum=`sha1sum "$1" | cut -d' ' -f1`
	local key="$REDO_DB_DIR/$1/.redo/checksum"
	db_affirm_key "$key"
	local old_checksum=`cat "$key"`
	db_write "$key" "$checksum"
	[ "$old_checksum" != "$checksum" ]
}

db_update_prereqs_checksums() {
	local i
	db_get_prereqs "$1"
	local prereqs="$db_result"
	if [ ! -z "$prereqs" ]; then
		for i in $prereqs
		do
			local checksum=`cat "$REDO_DB_DIR/$i/.redo/checksum"`
			db_write "$REDO_DB_DIR/$1/.redo/prereqs_checksums/$i" "$checksum"
		done
	fi
}

db_reset_uptodate() {
	find .redo -path '*/.redo/uptodate' -exec rm '{}' \;
}

db_mark_as_uptodate() {
	db_affirm_key "$REDO_DB_DIR/$1/.redo/uptodate"
}

db_is_uptodate() {
	[ -f "$REDO_DB_DIR/$1/.redo/uptodate" ]
}

db_outdated() {
	[ ! -f "$REDO_DB_DIR/$1/.redo/uptodate" ]
}

db_prereq_rebuilt() {
	local new_hash=`cat "$REDO_DB_DIR/$2/.redo/checksum"`
	local old_hash=
	local key="$REDO_DB_DIR/$1/.redo/prereqs_checksums/$2"
	if [ -f "$key" ]; then
		old_hash=`cat "$key"`
	fi

	[ "$new_hash" != "$old_hash" ]
}

db_write() {
	local key_dir=`dirname "$1"`
	mkdir -p "$key_dir"
	echo "$2" > "$1"
}

db_affirm_key() {
	local key_dir=`dirname "$1"`
	mkdir -p "$key_dir"
	if [ ! -f "$1" ]; then
		touch "$1"
	fi
}

find_build_script() {
	build_script="${1}.do"
	if [ -f "$build_script" ]; then
		return 0
	fi

	non_exist_build_scripts=
	non_exist_build_scripts="${non_exist_build_scripts}${IFS}${build_script}"

	local target_name=`basename "$1"`
	local search_dir=`dirname "$1"`
	local do_search_dir="y"
	while [ "$do_search_dir" = "y" ]
	do
		if [ "$search_dir" = "." ]; then
			do_search_dir="n"
		fi

		local search_base="${target_name#*.}.do"
		local do_search_name="y"
		while [ "$do_search_name" = "y" ]
		do
			if [ "$search_base" = "do" ]; then
				do_search_name="n"
			fi

			local filename="${search_dir}/default.${search_base}"
			if [ -f "$filename" ]; then
				build_script="$filename"
				return 0
			else
				non_exist_build_scripts="${non_exist_build_scripts}${IFS}${filename}"
			fi

			search_base="${search_base#*.}"
		done

		search_dir=`dirname "$search_dir"`
	done

	build_script=
	return 1
}

run_build_script() {
	redo_log "Building '$1' using '$2'"
	db_add_prereq "$1" "$2"
	db_update_own_checksum "$2"
	local temp_file="$REDO_DB_DIR/$1/.redo/doing"
	local script_path=`readlink -f "$2"`
	local target_basename=`basename "$1"`
	export REDO_LOG_PREFIX
	$REDO_BIN_DIR/redo-run \
		"$script_path" "$1" "$target_basename" "$temp_file" > "$temp_file"
	local status="$?"
	if [ $status -eq 0 ]; then
		mv "$temp_file" "$1"
		return 0
	else
		return $status
	fi
}

register_cmds() {
	local i
	for i in "$@"
	do
		local link_target="$REDO_BIN_DIR/redo-${i}"
		if [ `readlink -f "$link_target"` != "$REDO" ]; then
			rm -f "$link_target"
			ln -s "$REDO" "$link_target"
		fi
	done
}

try_dispatch_cmd() {
	local cmd_name="$1"
	local func_name="redo_${cmd_name}"
	shift
	if type $func_name 2>&1 > /dev/null; then
		$func_name $*
	else
		redo_log "redo: invalid command 'redo-${cmd_name}'"
		exit 1
	fi
}

main $*
